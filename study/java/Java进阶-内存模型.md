Java 虚拟机
    Java 虚拟机是Java平台的基石, 它是Java平台的组成部分, 其编译的代码保证硬件和操作系统的无关性.
   
   1. Java虚拟机的结构
        
        class 文件: 
            由Java虚拟机执行的编译代码使用硬件和操作系统独立的二进制格式表示，通常(但不一定)存储在文件中，称为类文件格式。
            类文件格式精确地定义了类或接口的信息，包括一些细节，例如可能被认为是特定于平台的对象文件格式的字节顺序。  
   2. 运行时数据区域 (内存模型)
   
        虚拟机栈: 
            为虚拟机执行Java字节码提供服务.
            每个线程都有一个私有的虚拟机栈. Java虚拟机栈的内存不需要是连续的, 并且允许可以是固定大小, 或者根据计算需要动态扩展和收缩.
            如果Java虚拟机栈的大小是固定的, 那么在创建该堆栈时, 可以独立地选择每个线程的大小.
            Java虚拟机实现可以提供程序员或用户控制Java虚拟机栈的初始大小，以及在动态扩展或收缩Java虚拟机栈的情况下，控制最大和最小大小。
            
            可能会遇到的异常:
                StackOverflowError: 如果Java虚拟机栈在运行时需要更大的空间,
                OutOfMemoryError: 如果Java虚拟机栈可以动态地扩展, 但是在扩展的时候发现可用的内存不足时. 或者在jvm新建一个线程时内存不足时.
        堆:
            所有线程共享的内存区域. 堆是运行时数据区域, 主要保存所有的对象实例和数组.
            在jvm启动时就被创建. 堆内存空间是GC(垃圾收集器)主要管理的区域. 堆内存的大小也可以是固定的或者自定义大小的. 换言之, 堆内存大小也是可控的.
            
            可能会遇到的异常:
                OutOfMemoryError: 当堆内存的可用空间不足时
        方法区:
        
            所有线程共享. 编译代码的存储区域. 它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括在类中使用的特殊方法和实例初始化和接口初始化。
            在jvm启动时就被创建. 尽管方法区域在逻辑上是堆的一部分, 但是垃圾收集器可能并不会对它进行垃圾回收处理.
            方法区的内存空间可以是固定的大小，也可以根据计算的要求进行扩展，如果不需要较大的方法区域，则可以收缩。方法区域的内存不需要是连续的。
            
            如果方法区域内的内存不能满足分配请求，那么Java虚拟机将抛出OutOfMemoryError。
            
        运行时常量池:
            包含了几种常量，从编译时已知的数字常量到必须在运行时解析的方法和字段引用。
            运行时常量池都是在堆内存中被分配的. 当jvm在创建类和接口时, 会为类和接口创建运行时常量池.
            当创建一个类或接口时，如果运行时常量池的构造需要更多的内存，单但Java虚拟机的方法区域中可用空间不足，那么Java虚拟机抛出一个OutOfMemoryError。
        
        本地方法栈:
            为虚拟机使用到的本地方法服务.     
            
        Garbage Collection (GC):
            
            GC所考虑到的事情:
                哪些内存需要回收?
                什么时候回收?
                如何回收?
            
            引用计数算法:
                给每一个对象中添加一个引用计数器, 每当有一个地方引用它, 计数器就加1, 当引用失效时计数器就减1. 任何时刻计数器为0的对象就是不可能再被使用的.
                
                在Java中存在一个问题:
                    当多个对象种循环引用时,导致的情况是, 当循环引用的对象被创建使用之后, 引用计数都不为0.
                    
            可达性分析算法:
                通过一系列的 GC Roots 的对象作为起始点, 冲这些节点开始向下搜索,搜索走过的路径称为引用链. 当对象到GCRoots没有任何引用链相连时, 则证明此对象是不可用的.