Java 虚拟机
    
    Java 虚拟机是Java平台的基石, 它是Java平台的组成部分, 其编译的代码保证硬件和操作系统的无关性.
   
1. Java虚拟机的结构
        
        class 文件: 
            由Java虚拟机执行的编译代码使用硬件和操作系统独立的二进制格式表示，通常(但不一定)存储在文件中，称为类文件格式。
            类文件格式精确地定义了类或接口的信息，包括一些细节，例如可能被认为是特定于平台的对象文件格式的字节顺序。  

2. 运行时数据区域 (内存模型)
   
    
    虚拟机栈:
        为虚拟机执行Java字节码提供服务.
        每个线程都有一个私有的虚拟机栈. 生命周期和线程相同. 每个方法执行的同时会创建一个栈帧用于存储局部变量表, 操作数栈, 动态链接, 方法出口等信息. 
        每一个方法从调用直至执行完成的过程, 就对应着一个栈帧在虚拟机栈中入栈到出栈的过程.
        可能会遇到的异常:
            StackOverflowError: 如果Java虚拟机栈在运行时需要更大的空间,
            OutOfMemoryError: 如果Java虚拟机栈可以动态地扩展, 但是在扩展的时候发现可用的内存不足时. 或者在jvm新建一个线程时内存不足时.
    堆:
        所有线程共享的内存区域. 堆是运行时数据区域, 主要保存所有的对象实例和数组.
        在jvm启动时就被创建. 堆内存空间是GC(垃圾收集器)主要管理的区域. 堆内存的大小也可以是固定的或者自定义大小的. 换言之, 堆内存大小也是可控的.
        
        可能会遇到的异常:
            OutOfMemoryError: 当堆内存的可用空间不足时
    方法区:
        所有线程共享. 编译代码的存储区域. 它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括在类中使用的特殊方法和实例初始化和接口初始化。
        在jvm启动时就被创建. 尽管方法区域在逻辑上是堆的一部分, 但是垃圾收集器可能并不会对它进行垃圾回收处理.
        方法区的内存空间可以是固定的大小，也可以根据计算的要求进行扩展，如果不需要较大的方法区域，则可以收缩。方法区域的内存不需要是连续的。
        如果方法区域内的内存不能满足分配请求，那么Java虚拟机将抛出OutOfMemoryError。
    运行时常量池:
        包含了几种常量，从编译时已知的数字常量到必须在运行时解析的方法和字段引用。
        运行时常量池都是在堆内存中被分配的. 当jvm在创建类和接口时, 会为类和接口创建运行时常量池.
        当创建一个类或接口时，如果运行时常量池的构造需要更多的内存，单但Java虚拟机的方法区域中可用空间不足，那么Java虚拟机抛出一个OutOfMemoryError。
    本地方法栈:
        为虚拟机使用到的本地方法服务.     
            
Garbage Collection (GC):
    
    GC所考虑到的事情:
        哪些内存需要回收?
        什么时候回收?
        如何回收?
    
    引用计数算法:
        给每一个对象中添加一个引用计数器, 每当有一个地方引用它, 计数器就加1, 当引用失效时计数器就减1. 任何时刻计数器为0的对象就是不可能再被使用的.
        在Java中存在一个问题:
            当多个对象种循环引用时, 导致的情况是, 当循环引用的对象被创建使用之后, 引用计数都不为0.
            
    可达性分析算法:
        通过一系列的 GC Roots 的对象作为起始点, 冲这些节点开始向下搜索,搜索走过的路径称为引用链. 当对象到GCRoots没有任何引用链相连时, 则证明此对象是不可用的.
    
    GC算法:
        1. 标记--清除
            标记阶段: 通过根节点搜索的方式, 标记所有不可达的对象
            清除阶段: 遍历堆内存, 找出标记为不可达的对象, 执行回收
            缺点:
                效率问题, 两个阶段的效率都不高. 根节点搜索需要遍历整个内存.
                空间问题, 当执行一次回收之后, 下一次执行回收之前如果需要分配的对象过大而无法找到足够大的连续空间, 会不得不触发第二次回收    
         
        2. 复制
            将可用内存分为相同大小的两份, 只使用其中一块, 每次回收将可达对象复制到另一份中, 然后清空使用的内存中的所有对象
            优点:
                不需要考虑内存碎片等情况, 实现简单, 效率高
            缺点:
                只能使用一半的内存, 持续复制长生存期的对象则导致效率降低
            
        3. 标记--整理 
            使用标记清除的方式, 根节点遍历找出存活的对象. 然后移动所有的存活对象, 按照内存地址顺序排列, 最后将末端对象全部回收.
        
    分代搜集算法
        
        根据对象存活周期的不同将内存划分为几块. 就像Java把堆分为新生代和老年代, 这样就可以根据各个年代的特点采用适当的搜集算法.
        新生代中使用的是复制算法
        老年代中使用标记整理 或标记清除来进行回收
        
垃圾搜集器:
    
    1. serial 搜集器
        单线程的搜集器. 新生代的唯一选择. 在它进行垃圾回收的时候必须短暂暂停其它工作线程(stop the world), 直到它手机结束. 
    2. ParNew 收集器
        serial的多线程版本
    3. parallel Scavenge 收集器
        新生代收集器, 使用复制算法的收集器, 也是并行的多线程收集器.
        目的是达到一个可控制的吞吐量. 吞吐量 = 运行用户代码的时间/(运行用户代码的时间 + 垃圾收集时间)
        
    4. CMS(Concurrent Mark Sweep) 收集器
        基于标记清除的算法来实现的. 运行步骤:
            初始标记        仅仅只标记一下 GC Roots 能直接关联的对象, 速度很快
            并发标记        进行GC Roots Tracing 的过程
            重新标记        修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录
            并发清除        
            
            前两个标记步骤仍然会 stop the world. 并发阶段会影响用户线程, 降低性能. 无法处理浮动垃圾, 就是在并发清理阶段用户线程产生的新的垃圾.
            基于标记清除实现, 收集结束后会产生空间碎片
            
    5. G1 收集器
        面向服务端的垃圾收集器. 
        特点:
            并行与并发, 可以充分利用多CPU 多核心环境下的硬件优势来缩短 stop the world 停顿的时间.
            分代收集
            空间整合, 从整体上看是基于 标记整理算法来实现, 从局部上来看是基于复制算法来实现. G1 运行期间不会产生内存空间碎片.
            可预测的停顿                                 